\documentclass{panikzettel}

\title{Panikzettel EMS}
\author{Kevin Conrads}

\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}

\maketitle

\tableofcontents

\section{Einleitung}
Dieser Panikzettel für das Fach ``Einführung in Management Science: Desgin und Analyse von Algorithmen'', gehalten im WS19/20 von Prof. Peis, ist ein freiwilliges Projekt, dass ich parallel zu meiner Tutortätigkeit in diesem Fach erstellt habe. Die Struktur folgt dabei in der Reihenfolge den Vorlesungsthemen, kann jedoch an sinnvollen Stellen davon abweichen.

Dieses Dokument hat \emph{nicht} zum Ziel, alleinige Ressource zum Lernen und Verstehen des Vorlesungsstoffes zu sein, sondern eine begleitende bzw. ergänzende Rolle zu den Materialien aus der Vorlesung und Übung einzunehmen. Trotz größter Sorgfalt können Fehler, die Inhalt, Form, Notation, etc. betreffen, nicht ausgeschlossen werden. Es liegt daher in der Verantwortung des/der Leser/Leserin, sich im Zweifel mit den betreffenden Lehrmaterialien der Vorlesung auseinanderzusetzen. Außerdem hafte ich nicht für falsche Antworten in z.B. der Klausur, aufgrund der Informationen in diesem Dokument getätigt wurden. 

Eltern haften für ihre Kinder.

\vspace{-0.5\baselineskip}
{\small{}
	\paragraph{Hinweis:}
	Das Latex-Template für diesen Panikzettel sowie das Konzept ``Panikzettel'' an sich sind übernommen bzw. angelehnt an das \href{https://git.rwth-aachen.de/philipp.schroer/panikzettel}{Panikzettel-Projekt}.

\section{Stabile Matchings}

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{defi}{Stable Marriage Problem}
	Das Stable Marriage Problem beschreibt, wie eine Menge von Männern und eine gleichgroße Menge von Frauen miteinander verlobt (\emph{gematched}) werden sollen, so das keiner einen Anreiz zu einem Seitensprung hat.\\
	
	\begin{itemize}
		\item Es gibt eine Menge an $n$ Männern und eine Menge an $n$ Frauen
		\item Jeder Mann listet die Frauen nach absteigender Präferenz
		\item Jede Frau listet die Männer nach absteigender Präferenz
		\item Gesucht ist ein Arrangement an $n$ Hochzeiten, das heißt ein \emph{perfektes Matching}
		\item Das Matching soll möglichst stabil sein: Keiner sollte einen Anreiz zu einem Seitensprung haben
	\end{itemize}
	\end{defi}
\end{halfboxl}%
\begin{halfboxr}
	 \vspace{-\baselineskip}
	Graph-Beispiel für das Stable Marriage Problem:\\
	
	\begin{center}
	\begin{tikzpicture}
	\node[draw,circle,minimum size=5mm, label = left:{$X,Z,W,Y$}] (A) at (0,0) {$A$};
	\node[draw,circle,minimum size=5mm, label = left:{$Y,W,X,Z$}] (B) at (0,-2) {$B$};
	\node[draw,circle,minimum size=5mm, label = left:{$Z,X,Y,W$}] (C) at (0,-4) {$C$};
	\node[draw,circle,minimum size=5mm, label = left:{$W,Y,Z,X$}] (D) at (0,-6) {$D$};
	
	\node[draw,circle,minimum size=5mm, label = right:{$A,B,C,D$}] (W) at (2,0) {$W$};
	\node[draw,circle,minimum size=5mm, label = right:{$B,D,C,A$}] (X) at (2,-2) {$X$};
	\node[draw,circle,minimum size=5mm, label = right:{$C,A,D,B$}] (Y) at (2,-4) {$Y$};
	\node[draw,circle,minimum size=5mm, label = right:{$D,B,A,C$}] (Z) at (2,-6) {$Z$};
	%\foreach \X [count=\Y from 2] in {1, ..., 3}{
	%	\draw[-] (\X) -- (\Y);
	%}
	\draw[thick] (A) -- (W);
	\draw[thick] (B) -- (X);
	\draw[thick] (C) -- (Z);
	\draw[thick] (D) -- (Y);
	\draw[thick,red] (A) -- (Z);
	\end{tikzpicture}
	
	Hier liegt ein instabiles Matching vor: $\{A,Z\}$ sind unzufrieden mit der Partnerwahl; sie finden sich gegenseitig besser als ihre jetzigen Partner und hätten damit Anlass für einen Seitensprung.
	\end{center}
\end{halfboxr}

%\vspace{0.5cm}

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{defi}{Matchings in Graphen}
	Sei $G = (V,E)$ ein ungerichteter Graph\\
	
	\begin{itemize}
	\item Eine Teilmenge $M$ der Kanten wird Matching gennant, wenn keine zwei Kanten in $M$ einen gemeinsamen Endknoten haben.
	
	\item Die Kardinalität $|M|$ (Anzahl der Kanten in $M$) eines Matchings $M$ ist nie größer als $\frac{|V|}{2}$
	
	\item Ein Matching $M$ mit $|M| = \frac{|V|}{2}$ heißt \emph{perfekt}
	
	\end{itemize}
	\end{defi}
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}
	\begin{defi}{Bipartite Graphen}
	Ein ungerichteter Graph $G = (V,E)$ heißt \emph{bipartit}, wenn sich die Knotenmenge $V$ so in zwei Hälften aufteilen lässt, dass\\
	
	\begin{itemize}
		\item $V = L \cup R$ (jeder Knoten ist entweder in $L$ oder in $R$),
		\item $L \cap R = \emptyset$ (kein Knoten liegt in beiden Mengen) und 
		\item das jede Kante einen Endknoten in $L$ und einen in $R$ besitzt.
	\end{itemize}
	\end{defi}
\end{halfboxr}

\begin{defi}{Blockierende Kante und Stabiles Matching}
	Eine Kante ${u,v}$ heißt \emph{blockierend} (für ein Matching $M$), wenn der Knoten $u$ den Knoten $v$ gegenüber seinem jetzigen Partner präferiert und umgekehrt.
	
	Ein Matching $M$ ist \emph{stabil}, wenn es keine blockierende Kante im Graphen gibt.
	
	\textit{(Im Beispiel Graph oben ist die rot gezeichnete Kante $\{A,Z\}$ eine blockierende Kante für das Matching.)}
\end{defi}

Hier sollte deutlich werden, dass das Stable Marriage Problem äquivalent zum Stable Matching Problem in bipartiten Graphen ist.

Das ``Reduzieren'' von Problem aus der Realität auf Probleme z.B. der Graphentheorie ist eine weit verbreitete Technik. Man folgt der Idee: Wenn man einen Algorithmus A hat, der ein (abstraktes) (Graphen-)Problem X löst, und ein reales Problem Y auf das Problem X reduzierbar (oder äquivalent) ist, dann kann man auch Problem Y mit dem Algorithmus A lösen.

\subsection{Exkurs: Stable Roommate Problem}

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{defi}{Stable Roommate Problem}
		Das Stable Roommate Problem beschreibt, wie eine Menge von Personen anhand von Präferenzen in Paare aufgeteilt werden kann, sodass das resultierende Matching stabil ist.\\
		
		\begin{itemize}
			\item Gegeben: $2n$ Personen; jede Person sortiert die anderen $2n-1$ Personen in einer Präferenzlist
			\item Gesucht: Eine Aufteilung der $2n$ Personen in $n$ Paare, so dass das entsprechende (perfekte) Matching stabil ist.
		\end{itemize}
	
		Beim Stable Roommate Problem gibt es nicht immer ein stabiles perfektes Matching (siehe Beispiel rechts).
	\end{defi}
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}	
	\begin{center}
		\begin{tikzpicture}
		\node[draw,circle,minimum size=5mm, label = above:{$B,C,D$}] (A) at (2,0) {$A$};
		\node[draw,circle,minimum size=5mm, label = left:{$C,A,D$}] (B) at (0,-2) {$B$};
		\node[draw,circle,minimum size=5mm, label = below:{$A,B,D$}] (C) at (2,-4) {$C$};
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C$}] (D) at (4,-2) {$D$};
		
		%\foreach \X [count=\Y from 2] in {1, ..., 3}{
		%	\draw[-] (\X) -- (\Y);
		%}
		\draw[thick,red] (A) -- (B);
		\draw[thick,green] (B) -- (C);
		\draw[thick,red] (C) -- (D);
		\draw[thick,green] (D) -- (A);
		\draw[thick,blue] (A) -- (C);
		\draw[thick,blue] (B) -- (D);
		\end{tikzpicture}
		
		Alle Möglichkeiten an Matchings (rot, blau, grün) sind nicht stabil.
	\end{center}
\end{halfboxr}

\subsection{Algorithmen zum Lösen des Stable Marriage Problems}

Es gibt zwei Algorithmen, die hier betrachtet werden: Die Seitensprung-Dynamik und Gale-Shapley-Algorithmus.

\subsubsection{Seitensprung-Dynamik}
\begin{algo}
	\textbf{Eingabe:} Beliebiges Matching $M$
	
	\textbf{Ausgabe:} Stabiles, perfektes Matching $M^*$.
	\tcblower
	
	\textbf{WHILE} (unzufriedenes Paar $\{m,w\}$ existiert)

	\tab Ersetze die Matchingkanten $\{m,w'\}$ und $\{m',w\}$ durch $\{m,w\}$ und $\{m',w'\}$
   
	\textbf{RETURN} $M^*$
	
\end{algo}

Folgender Graph zeigt eine Iteration innerhalb der \textbf{WHILE} Schleife:

\begin{halfboxl}
	\vspace{-\baselineskip}	
	\begin{center}
		\begin{tikzpicture}
		\node[draw,circle,minimum size=5mm, label = left:{$X,Z,W,Y$}] (A) at (0,0) {$A$};
		\node[draw,circle,minimum size=5mm, label = left:{$Y,W,X,Z$}] (B) at (0,-2) {$B$};
		\node[draw,circle,minimum size=5mm, label = left:{$Z,X,Y,W$}] (C) at (0,-4) {$C$};
		\node[draw,circle,minimum size=5mm, label = left:{$W,Y,Z,X$}] (D) at (0,-6) {$D$};
		
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C,D$}] (W) at (2,0) {$W$};
		\node[draw,circle,minimum size=5mm, label = right:{$B,D,C,A$}] (X) at (2,-2) {$X$};
		\node[draw,circle,minimum size=5mm, label = right:{$C,A,D,B$}] (Y) at (2,-4) {$Y$};
		\node[draw,circle,minimum size=5mm, label = right:{$D,B,A,C$}] (Z) at (2,-6) {$Z$};
		\node[red] (m) at (0,0.55) {m};
		\node[red] (w) at (2.1,-5.45) {w};
		\node[red] (m2) at (0,-3.45) {m'};
		\node[red] (w2) at (2,0.55) {w'};
		
		%\foreach \X [count=\Y from 2] in {1, ..., 3}{
		%	\draw[-] (\X) -- (\Y);
		%}
		\draw[thick] (A) -- (W);
		\draw[thick] (B) -- (X);
		\draw[thick] (C) -- (Z);
		\draw[thick] (D) -- (Y);
		\draw[thick,red] (A) -- (Z);
		\end{tikzpicture}
	\end{center}

	$\{A,Z\}$ sind unzufrieden. Löse Verbindung $\{A,W\}$ und $\{C,Z\}$ auf und ...
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}	
	\begin{center}
		\begin{tikzpicture}
		\node[draw,circle,minimum size=5mm, label = left:{$X,Z,W,Y$}] (A) at (0,0) {$A$};
		\node[draw,circle,minimum size=5mm, label = left:{$Y,W,X,Z$}] (B) at (0,-2) {$B$};
		\node[draw,circle,minimum size=5mm, label = left:{$Z,X,Y,W$}] (C) at (0,-4) {$C$};
		\node[draw,circle,minimum size=5mm, label = left:{$W,Y,Z,X$}] (D) at (0,-6) {$D$};
		
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C,D$}] (W) at (2,0) {$W$};
		\node[draw,circle,minimum size=5mm, label = right:{$B,D,C,A$}] (X) at (2,-2) {$X$};
		\node[draw,circle,minimum size=5mm, label = right:{$C,A,D,B$}] (Y) at (2,-4) {$Y$};
		\node[draw,circle,minimum size=5mm, label = right:{$D,B,A,C$}] (Z) at (2,-6) {$Z$};
		
		\node[red] (m) at (0,0.55) {m};
		\node[red] (w) at (2.1,-5.45) {w};
		\node[red] (m2) at (0,-3.45) {m'};
		\node[red] (w2) at (2,0.55) {w'};
		
		%\foreach \X [count=\Y from 2] in {1, ..., 3}{
		%	\draw[-] (\X) -- (\Y);
		%}
		\draw[thick, lightgray] (A) -- (W);
		\draw[thick] (B) -- (X);
		\draw[thick,lightgray] (C) -- (Z);
		\draw[thick] (D) -- (Y);
		\draw[thick] (A) -- (Z);
		\draw[thick] (C) -- (W);
		\end{tikzpicture}
	\end{center}
	verbinde $\{A,Z\}$ und $\{C,W\}$. Die aufgelösten Kanten sind hier grau gefärbt.
\end{halfboxr}

\begin{theo}{Korrektheit der Seitensprung-Dynamik}
	Die Seitensprung-Dynamik terminiert nicht für jede Eingabe. Das heißt es wird nicht für alle Eingaben ein stabiles Matching gefunden. (Wenn man das Beispiel oben weiterführt, landet man irgendwann wieder an der Ausgangsposition).
\end{theo}

\subsubsection{Gale-Shapley Algorithmus}

Es gibt jedoch einen Algorithmus, der stets ein stabiles Matching findet:

\begin{algo}{Gale-Shapley}
	\textbf{Eingabe:} Ein bipartiter Graph $G$ mit einer Präferenzliste an jedem Knoten
	
	\textbf{Ausgabe:} Stabiles, perfektes Matching $M^*$.
	\tcblower
	
	Zu Beginn sind alle Männer und Frauen ungematched
	
	\textbf{WHILE} (es noch einen freien Mann gibt, der noch nicht allen Frauen einen Antrag gemacht hat)
	
	\tab Wähle einen solchen freien Mann $M$
	
	\tab Lasse diesen der besten Frau $w$ auf seiner Liste einen Antrag machen
	
	\tab \textbf{IF} (Frau $w$ ist noch frei)
	
	\tab\tab Verlobe $m$ und $w$
	
	\tab \textbf{ELSE} 
	
	\tab\tab  \textbf{IF} ($w$ findet $m$ besser als ihren aktuellen Verlobten $m'$)
	
	\tab\tab\tab Hebe die Verlobung von $w'$ und $m'$ auf
	
	\tab\tab\tab Verlobe $m$ und $w$
	
	\tab\tab\tab Streiche $w'$ von der Liste von $m'$
	
	\tab\tab \textbf{ELSE}
	
	\tab\tab\tab Streiche $w$ von der Liste von $m$
	
	Verheirate alle verlobten Paare
	
	\textbf{RETURN} das resultierende Matching $M^*$ von verheirateten Paaren
\end{algo}

Man beachte, dass ein Mann $m$ nur dann mit einer Frau $w$ verlobt wird, wenn entweder $w$ noch keinen Partner hat, oder wenn $w$ denn Mann $m$ besser als ihren bisherigen Verlobten $m'$ findet. Im Umkehrschluss bedeutet dies, das ein bereits verlobter Mann $m'$ seine Verlobte dadurch verlieren kann und wieder in die Liste der Männer hinzugefügt wird, die noch nicht allen Frauen einen Antrag gemacht hat. 

Ein perfektes Matching ist stabil, wenn entweder 
\begin{itemize}
	\item jeder Mann seine erste Wahl zur Partnerin hat, oder
	\item jede Frau ihre erste Wahl als Partner hat,
\end{itemize}
da so niemand den Anreiz zu einem Seitensprung hätte (dieser Fall tritt jedoch selten ein). Für Gale-Shapley gilt unabhängig davon:

\begin{theo}{Korrektheit von Gale-Shapley}
	Gale-Shapley berechnet stets ein stabiles perfektes Matching. 
	
	Der Algorithmus hat eine Laufzeit von $\mathcal{O}(n^2)$, wobei $n$ der Anzahl der Männer bzw. der Frauen entspricht.
\end{theo}

Unter Umständen kann es mehrere stabile Matchings in einem Graphen geben, daher stellt sich die Frage, welches Gale-Shapley findet. Man stellt zunächst fest, dass Gale-Shapley die Männer bevorzugt, da diese aktiv auswählen und die Frauen nur passiv abwarten. 

\begin{thirdboxl}
	\vspace{-\baselineskip}	
	\begin{defi}{Zulässige Partnerin}
		Eine Frau $w$ ist eine \emph{zulässige Partnerin} von Mann $m$, wenn es ein stabiles perfektes Matching gibt, bei dem $m$ und $w$ ein Paar bilden.
	\end{defi}

	\begin{defi}{Mann-optimal}
		Ein Matching wird \emph{Mann-optimal} genannt, wenn jeder Mann mit seiner bevorzugten zulässigen Partnerin zusammen ist
	\end{defi}
\end{thirdboxl}%
\begin{thirdboxm}
	\vspace{0.7cm}	
	\begin{center}
		\begin{tikzpicture}
		\node[draw,circle,minimum size=5mm, label = left:{$X,Y,Z$}] (A) at (0,0) {$A$};
		\node[draw,circle,minimum size=5mm, label = left:{$Y,X,Z$}] (B) at (0,-2) {$B$};
		\node[draw,circle,minimum size=5mm, label = left:{$X,Y,Z$}] (C) at (0,-4) {$C$};
	
		\node[draw,circle,minimum size=5mm, label = right:{$B,A,C$}] (X) at (2,0) {$X$};
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C$}] (Y) at (2,-2) {$Y$};
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C$}] (Z) at (2,-4) {$Z$};
		
		\draw[thick,red] (A) -- (X);
		\draw[thick,red] (B) -- (Y);
		\draw[thick,red] (C.315) -- (Z.225);
		\draw[thick,blue] (A) -- (Y);
		\draw[thick,blue] (B) -- (X);
		\draw[thick,blue] (C.45) -- (Z.135);
		\end{tikzpicture}
	\end{center}
\end{thirdboxm}%
\begin{thirdboxr}
	\vspace{1.5cm}	
	\begin{itemize}
		\item $X$ und $Y$ sind zulässige Partnerinnen von $A$
		\item $X$ und $Y$ sind zulässige Partnerinnen von $B$
		\item nur $Z$ ist zulässige Partnerin von $C$. Jedes perfekte stabile Matching muss deshalb die Kante $\{C,Z\}$ enthalten
	\end{itemize}
\end{thirdboxr}

\begin{theo}{Gale-Shapley und Matchings}
	\begin{itemize}
		\item Mann-optimale Matchings sind perfekt und stabil.
		\item Gale-Shapley liefert stets ein Mann-optimales Matching.
		\item Gale-Shapley weist jeder Frau den für sie schlechtesten zulässigen Partner zu
	\end{itemize}

\end{theo}

\subsection{Kontext des Stable Marriage Problems: College Admission}

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{defi}{College Admission Problem}
		Es gibt Studierende und Universitäten mit jeweiligen Präferenzen, die einander zugeteilt werden sollen.\\
		
		\begin{itemize}
			\item Studierende bzw. Universitäten können als inakzeptabel deklariert werden
			\item Es gibt nicht unbedingt gleich viele Studierende wie Unis
			\item Jede Uni hat eine Quote, die die maximale Anzahl zugewiesener Studis festlegt
		\end{itemize}
	
	Eine Zuweisung (hier spricht man nicht mehr von Matching, wie es oben definert wurde) ist zulässig, wenn jeder Studi einer akzeptable Uni zugewiesen wurde und jeder Uni nur akzeptable Studis zugewiesen wurde. Auch hier kann es analog "blockierende" Kanten geben.
	\end{defi}
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}
	Graph-Beispiel für das Stable Marriage Problem:\\
	
	\begin{center}
		\begin{tikzpicture}
		\node[draw,circle,minimum size=5mm, label = left:{$X,Z,W,Y$}] (A) at (0,0) {$A$};
		\node[draw,circle,minimum size=5mm, label = left:{$Y,W,X,Z$}] (B) at (0,-2) {$B$};
		\node[draw,circle,minimum size=5mm, label = left:{$Z,X,Y,W$}] (C) at (0,-4) {$C$};
		\node[draw,circle,minimum size=5mm, label = left:{$W,Y,Z,X$}] (D) at (0,-6) {$D$};
		
		\node[draw,circle,minimum size=5mm, label = right:{$A,B,C,D$}] (B) at (2,0) {Berlin};
		\node[draw,circle,minimum size=5mm, label = right:{$B,D,C,A$}] (X) at (2,-2) {Aachen};
	
		\draw[thick] (A) -- (W);
		\draw[thick] (B) -- (X);
		\draw[thick] (C) -- (Z);
		\draw[thick] (D) -- (Y);
		\draw[thick,red] (A) -- (Z);
		\end{tikzpicture}
		
		Hier liegt ein instabiles Matching vor: $\{A,Z\}$ sind unzufrieden mit der Partnerwahl; sie finden sich gegenseitig besser als ihre jetzigen Partner und hätten damit Anlass für einen Seitensprung.
	\end{center}
\end{halfboxr}

\section{Sortieren}

Grundsätzlich in diesem Kapitel, sowie in allen folgenden, beginnen Arrays bzw. Listen immer mit dem Index 0. Das heißt, in einem Array $A$ mit z.B. 3 Elementen, gibt es die Position $A[0]$, $A[1]$ und $A[2]$. Das erste Element eines $n$-elementigen Arrays $A$ ist also $A[0]$ und das letzte $A[n-1]$.

\subsection{Insertion Sort und Merge Sort}

Insertion Sort ist ein Sortierverfahren, dass jedes Element eines Arrays an die richtige Stelle im bereits sortierten Teilarray einfügt (``insertion''). Merge Sort hingegen teilt das Array rekursiv in zwei Teillisten und ``mergt'' diese dann zu sortierten Teillisten zusammen.

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{algo}{Insertion Sort}
		\textbf{Eingabe:} Array der Länge $n$
		
		\textbf{Ausgabe:} Aufsteigend sortiertes Array $A$
		\tcblower
		
		\textbf{FOR} $j=1$ \textbf{TO} $n-1$
		
		\tab $key$ = $A[j]$
		
		\tab $i = j-1$
		
		\tab \textbf{WHILE} ($i>0$ \textbf{AND} $A[i]>key$)
		
		\tab\tab $A[i+1] = A[i]$
		
		\tab\tab $i =i-1$
		
		\tab $A[i+1] = key$
		
		\textbf{RETURN} $A$
	\end{algo}
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}
	\begin{algo}{Merge Sort}
		\textbf{Eingabe:} Array der Länge $n$
		
		\textbf{Ausgabe:} Aufsteigend sortiertes Array $A$
		\tcblower
		
		\textbf{IF} ($n=1$)
		
		\tab \textbf{RETURN} $A$
		
		Sortiere $A[1 \dots \frac{n}{2}]$ und $A[\frac{n}{2} +1 \dots n]$ rekursiv
		
		Merge die beiden sortierten Teilarrays
		
		\textbf{RETURN} $A$
	\end{algo}
\end{halfboxr}

\subsection{Selection Sort und Bubble Sort}

\begin{halfboxl}
	\vspace{-\baselineskip}
	\begin{algo}{Selection Sort}
		\textbf{Eingabe:} Array der Länge $n$
		
		\textbf{Ausgabe:} Aufsteigend sortiertes Array $A$
		\tcblower
		
		\textbf{FOR} $j=0$ \textbf{TO} $n-1$
		
		\tab $i_{\min}$ = $j$
		
		\tab \textbf{FOR} $i = j + 1 $ \textbf{TO} $n-1$
		
		\tab\tab \textbf{IF} ($A[i] < A[i_{\min}]$)
		
		\tab\tab\tab $i_{\min} = i$
		
		\tab \textbf{IF} ($i_{\min} \neq j$)
		
		\tab\tab Tausche $A[j]$ und $A[i_{\min}]$
		
		\textbf{RETURN} $A$
	\end{algo}
\end{halfboxl}%
\begin{halfboxr}
	\vspace{-\baselineskip}
	\begin{algo}{Bubble Sort}
		\textbf{Eingabe:} Array der Länge $n$
		
		\textbf{Ausgabe:} Aufsteigend sortiertes Array $A$
		\tcblower
		
		\textbf{IF} ($n=1$)
		
		\tab \textbf{RETURN} $A$
		
		Sortiere $A[1 \dots \frac{n}{2}]$ und $A[\frac{n}{2} +1 \dots n]$ rekursiv
		
		Merge die beiden sortierten Teilarrays
		
		\textbf{RETURN} $A$
	\end{algo}
\end{halfboxr}

Selection Sort

Bubble Sort


\section{Laufzeit}

\section{Interval-Scheduling und Partitioning}

\section{Graphentheorie}

\section{Minimale Spannbäume}

\section{Einführung in Spieltheorie}

\section{Networkflow und Project Selection}

\section{Matching Markets}

\section{Prolog}

\end{document}